//! Functionality for handling Anki cards and decks.

mod kanji;
mod word;

pub use self::{
    kanji::{Kanji, KanjiCard, KanjiWord},
    word::{Furigana, Sentence, SentenceWord, WordCard, WordKanji},
};
use genanki_rs::Deck;
pub use genanki_rs::Package;

/// Data that makes up an Anki card.
#[derive(Debug, PartialEq, Eq)]
pub enum Card {
    Word(WordCard),
    Kanji(KanjiCard),
}

impl PartialOrd for Card {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Card {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match (self, other) {
            (Self::Word(l), Self::Word(r)) => l.word_sentences.cmp(&r.word_sentences).reverse(),
            (Self::Kanji(l), Self::Kanji(r)) => l.kanji_words.cmp(&r.kanji_words).reverse(),
            (Self::Word(_), Self::Kanji(_)) => std::cmp::Ordering::Greater,
            (Self::Kanji(_), Self::Word(_)) => std::cmp::Ordering::Less,
        }
    }
}

pub fn create_deck(name: &str, id: i64, mut cards: Vec<Card>) -> Package {
    let mut deck = Deck::new(id, name, "Deck automatically generated by lbr");
    let word_model = word::create_model();
    let kanji_model = kanji::create_model();
    cards.sort();
    for card in cards {
        match card {
            Card::Word(card) => deck.add_note(card.into_note(&word_model)),
            Card::Kanji(card) => deck.add_note(card.into_note(&kanji_model)),
        }
    }
    Package::new(vec![deck], Vec::new()).expect("Failed to create package")
}
